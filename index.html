<html>
<head>
<title>LazerHead: Escape from Planetl Hades!!!</title>
</head>
<body>
  <canvas id='canvas' width='800' height='600'></canvas>
  <script type="text/javascript">
//helper functions
    window.requestAnimFrame = (function(){
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function( callback ){
          window.setTimeout(callback, 1000 / 60);
        };
        
    })();

    function rand(lo,hi) {
      return lo + Math.random()*(hi-lo);
    }

    function randColor() {
      return '#'+Math.floor(Math.random()*16777215).toString(16);
    }


    var pressed = {};
    var player = new Box(0,300,50,100);
    
    var monolith = new Box(300,300,500,200);
    var effects = [];
    var ground = 500;

    var camera = 0;
    
    var ctx = document.getElementById('canvas').getContext('2d');


    var skyline1 = [];
    for(var i=0; i<200; i++){
      skyline1[i] = rand(20,250);
    }


    var skyline2 = [];
    for(var i=0; i<100; i++){
      skyline2[i] = rand(50,200);
    }

    var skyline3 = []
    var skyline3dists = []
    var skyline3widths = []
    for(var i=0; i<100; i++){
      skyline3[i] = rand(250,400);
      skyline3dists[i] = rand(250,500);
      skyline3widths[i] = rand(50,100);
    }

    var starsCount = 250;
    var starxs =[]
    var starys =[]
    var starrads =[]
    for(var i=0; i<starsCount;i++){
      starxs.push(rand(-50,1000));
      starys.push(rand(0,ground));
      starrads.push(rand(1,4));
    }



    


    function setup() {
      document.addEventListener('keydown', function(e){
        pressed[e.keyCode] = true;
      });
      
      document.addEventListener('keyup', function(e){
        pressed[e.keyCode] = false;
      });

      player.dy = 0;
      player.power = 25;
      player.maxpower = 150;
    }
    



    function gameLoop() {
      processInput();
      updateGameState();
      checkConditions();
      processAnimations();
      draw();
      cleanUp();
      window.requestAnimFrame(gameLoop);
    }
    
    
    function processInput() {

    }

     
    var jumping = false;
    function updateGameState() {

      if(pressed['A'.charCodeAt(0)] == true) {
        player.x -= 3;
      }
      if(pressed['D'.charCodeAt(0)] == true) {
        player.x += 3;
      }

      if(pressed[' '.charCodeAt(0)] == true) {
        if(!jumping && player.getBottom()>0){
          player.dy -= 30;
          jumping = true;
        }}
      else {
        jumping = false;
      }
      
      if(pressed['J'.charCodeAt(0)] == true){
        effects.push(new lazerEffect(player.x+player.w-20,player.y));
        if(player.getBottom() < ground){ 
          player.x -= (Math.pow(player.power,2))*0.0010; 
        }else{
          player.x -= (Math.pow(player.power,2))*0.000325;
        }
        if(player.power > 10){player.power -= 0.1;};
      }
      
      
      if(pressed['L'.charCodeAt(0)] == true){
        if(player.power < player.maxpower){
          console.log("Aaaaaaaaaaa!!!")
          player.power += 0.5;
        } else {
          console.log("MAX POWER!");
        }
          
          
      }
      
      //float while using lazer!
      if(pressed['J'.charCodeAt(0)] != true){     
        player.y += player.dy;
        player.dy += 1;

      }

      camera = player.x - 200;


      if(rand(0,100) > 99){
        effects.push(new lavaBallEffect());
      }
      
      monolith.updateStatus();
      player.updateStatus();
    }


    function checkConditions() {
      if(player.intersects(monolith)){
        console.log("player hit monolith");
      }
        
      if(player.getBottom() > ground){
        player.dy = 0;
        player.setBottom(ground);
      }

      if(player.getBottom() < 0){
        player.setBottom(0);
      }
      
      
    }


    var tick = 0;
    function processAnimations() {

    }

    function drawBackground(ctx){
      // background - sky
      ctx.fillStyle = "#111122";
      ctx.fillRect(0,0,800,600);

    }

    function drawGround(ctx){
      //ground
      ctx.fillStyle = "#555555";
      ctx.fillRect(0,500,800,100);
    }

    function drawPlayer(ctx){
      ctx.save();
      //player
      ctx.fillStyle = "white";
      player.fillRect(ctx);
      ctx.restore();
    }

    function drawWalls(ctx){
      //monolith
      if(monolith.health > 0){
        ctx.fillStyle = "#a9a9a9";
        monolith.fillRect(ctx);
      }

    }


    function drawStarfield(ctx){
      ctx.save();
      ctx.translate(-camera/10,0);
      for(var i=0; i < starsCount ; i++){
        ctx.fillStyle = "#ffffaa;"
        //g.globalAlpha = rand(0.01,0.1);
        ctx.beginPath();
        rdiff = rand(0.9,1.1);        
        ctx.arc(starxs[i],starys[i],starrads[i]*rdiff,0,Math.PI*2,true);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();         
    }

    function drawSkyline1(ctx){
      ctx.save();
      ctx.translate(-camera/3,0);
      ctx.fillStyle = "#222230";
      for(var i in skyline1) {
        var h = skyline1[i];
        ctx.fillRect(i*25-200,ground - h,26,h);
      }
      ctx.restore();

    }

    function drawSkyline2(ctx){
      ctx.save();
      ctx.translate(-camera/2,0);
      ctx.fillStyle = "#333344";
      for(var i in skyline2) {
        var h = skyline2[i];
        ctx.fillRect(i*50-200,ground - h,51,h);
      }
      ctx.restore();
    }

    function drawSkyline3(ctx){
      ctx.save();
      ctx.translate(-camera/1.3,0);
      ctx.fillStyle = "#555567";
      for(var i in skyline3) {
        var h = skyline3[i];
        ctx.fillRect(i*skyline3dists[i],ground - h,skyline3widths[i],h);
      }
      ctx.restore();
    }


    function drawEffects(ctx){
      //effects
      effects.forEach(function(ef){
        ef.tick();
        ef.draw(ctx);
      });
    }


    function draw() {
      drawBackground(ctx);
      drawStarfield(ctx);
      drawSkyline1(ctx);
      drawSkyline2(ctx);
      drawSkyline3(ctx);
     
      drawGround(ctx);
      ctx.save();
      ctx.translate(-camera,0);
      drawPlayer(ctx);
      drawWalls(ctx);
      drawEffects(ctx);
      ctx.restore();
    }
    function refresh() {}
    
    function Box(x,y,w,h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.health = this.w*this.h;
      this.damageCooldown = 0;
      this.fillRect = function(ctx) {
        ctx.fillRect(this.x,this.y,this.w,this.h);
      }
      this.getRight = function() { return this.x + this.w ; }
      this.getLeft = function(){ return this.x; }
      this.getTop = function(){return this.y; }
      this.getBottom = function(){ return this.y + this.h;}
      
      this.setRight = function(right){ this.x = right - this.w;
                              }
      this.setLeft = function(left){ this.x = left;
                            }
      this.setBottom = function(bottom){ this.y = bottom - this.h;
                                }
      this.setTop = function(top) { this.y = top;
                           }
      
      this.intersects = function(box) {
        if(box.health <= 0){return false;
                                    }
        if(this.getRight() >= box.getLeft() 
           && this.getLeft() <= box.getRight()) {
        if(this.getBottom() >= box.getTop() &&
           this.getTop() <= box.getBottom()){
          return true;
        }
          
        }
        return false;
      }

      this.intersectedByPoint = function(x,y) {
        if(this.health <= 0){return false;
                                    }
          
        if(this.getRight() >= x
           && this.getLeft() <= x) {
        if(this.getBottom() >= y &&
           this.getTop() <= y){
          return true;
        }
          
        }
        return false;
      }
      
      this.damage = function(d){
        this.health -= d;
        if(this.damageCooldown == 0){
          this.damageCooldown = 5;
          effects.push(new boxDamageEffect(this));
        }

      }
      
      //this is an optional method for boxes that may take damage
      //and potentially be more interactive later
      this.updateStatus = function(){
        if(this.damageCooldown > 0){
          this.damageCooldown--;
        }
          
      }
      
      
    }

function lavaBallEffect(){
    
    this.age = 0;
    this.maxage = 800;
    this.size = rand(20,50);
    this.x = player.x - 350;
    this.y = rand(ground-this.size,0);
    this.box = new Box(this.x+this.size*0.15,this.y+this.size*0.15,this.size*0.7,this.size*0.7);
    this.dx = rand(2,4);
    this.tick = function(){
      this.age++;
      this.x += this.dx;
      this.box.x += this.dx;
      if(this.box.intersects(player)){
        console.log("ouch!")
        player.y -= 10;
        player.x += 30;
        this.age = this.maxage;
        player.damage(Math.sqrt(this.x*this.y));
      }
      
    }
    
    this.draw = function(g){
      g.save();

      g.fillStyle = "#dd2222";
      this.box.fillRect(g);
      g.globalAlpha = 0.6;
      g.fillStyle = "#dddd22";
      g.fillRect(this.x,this.y,this.size,this.size);

      g.restore();
    }
    
         
    this.isAlive = function(){
      return this.age < this.maxage;
    }
    
    
}

    
function boxDamageEffect(box){
    this.box = box;
    this.age = 0;
    this.maxage = 4;
    this.damageColor = "#ffff00"
    this.tick = function(){
      this.age++
    }
    
    this.draw = function(g){
      g.fillStyle = this.damageColor;
      this.box.fillRect(g);
    }
    
    this.isAlive = function(){
      return this.age < this.maxage;
    }
    
       

}


function lazerEffect(x,y){
    this.x = x;
    this.dx = 5;
    this.y = y;
    this.age = 0;
    this.maxage = player.power*2;
    this.alive = true;
    this.power = player.power
    this.color = "#ff0000";
    this.tick = function(){
      this.age++;
     
      if(!monolith.intersectedByPoint(this.x,this.y)){    
        this.x += this.dx;
      } else if(this.alive) {
        this.age += 5;
        monolith.damage(this.radius());
      }

      this.y;
      if(this.age > this.maxage) {
        this.alive = false;
        return;
      }
    }
    
    this.radius = function(){
      return ((0.5*this.power)*(1-(this.age/this.maxage))+(0.40*this.power));
    }

    this.draw = function(g) {
      if(!this.alive) return;

      g.save();
      g.fillStyle = this.color;
      g.globalAlpha = rand(0.01,0.1);
      //g.fillRect(this.x,this.y,20,20*(1-(this.age/this.maxage)));
      g.beginPath();
      g.arc(this.x,this.y,this.radius(),0,Math.PI*2,true);
      g.closePath();
      g.fill();
      g.restore();}
    
    //isAlive will be used to remove effects from global effects list
    this.isAlive = function(){
      return this.age < this.maxage;
    }
    
}


    function cleanUp(){
      effects = effects.filter(function(ef){return ef.isAlive();                                            });

    }


    setup();
    window.requestAnimFrame(gameLoop);

</script>
</body>
</html>
